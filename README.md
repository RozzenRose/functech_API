## functech_API

### О проекте:
Все построено на `FastAPI`. Для взаимодействия с БД используется `SQLAlchemy`. В качестве самой БД `PostgreSQL`. Конфигурирует БД `Alembic`. Так же используется `Redis` для кэширования.

Все параметры, переменные окружения и `URL` собираются через `pytdentic_settings`. Так же мы валидируем данные через `pytdantic`.

Применен `Celery`, под него написан воркер, который просто каждую минуту меняет статус заказа в БД и в кэше, пока не дойдет до статуса `Canceled`. По принципу - `PENDING`->`PAID`->`SHIPPED`->`CANCELED`
В качестве брокера сообщений использован `RabbitMQ`

Настроена виртуализация через `Docker`. Контейнеры `PostgreSQL`, `RabbitMQ` и `Redis` развертываются автоматически через `docker compose`. Также композер сам запустит `uvicorn` и скрипт `alembic` для конфигурации БД, а еще композер запустит `Celery`-воркер.

Файл `.env` добавлен на `git` не по ошибке. А что бы клонеры могли поднимать приложение одной командой.

Есть простая реализация `CORS`- защиты.

Rate limit защита тоже реализована.

## Функционал:
### Аутентификация
Реализован весь стандартный функционал для авторизации и аутентификации через систему `access/refresh` токенов. 

`POST /auth/create_user` - создает юзера
```
{
  "username": "string",
  "email": "string",
  "password": "string"
}
```

`POST /auth/token` - логинит юзера

`GET /auth/me` - вернет данные по твоему access JWT

`POST /auth/refresh` - обновит твой access, если прислать refresh

### Работа с данными
`POST /orders/create_new_order` - создает заказ
```
{
  "items": {
    "additionalProp1": {}
  },
  "total_price": 0
}
```
Под капотом просто отправляет данные в БД. А так же закидывает их в `Celery`-воркер. Воркер каждую минуту приходит в БД и в кэш и обновляет статус заказа на следующий.

`GET /orders/{order_id}` - присылает все данные о заказе с `order_id`
Под капотом пойдет проверять есть ли данные о таком заказе в `Redis`, если их там нет, данные будут взять в БД, после чего их закинет в `Redis` и отправит юзеру. Если повторить запрос в течении следующих 5ти минут, эти данные будут сразу взяты из кэша, база данных уже не трогаем 

`PATCH /orders/update` обновляет статус заказа
```
{
  "order_id": "string",
  "new_status": "string"
}
```
Обновляет статус заказа в БД, если заказ есть в кэше, обновит его еще и там.

`GET /orders/user/{user_id}` - пришлет все заказы юзера по его `user_id`
Он проверит есть ли данные о пользователе в кэше, если они там есть, то они просто будут предоставлены пользователю. Если их там нет, данные будут взяты из БД, ими будет обновлен кэш и потом эти данные отправятся юзеру. При создании новых заказов кэш заказов пользователя будет дропнут, потому что он будет считаться не достоверным. Лучше при следующем запросе еще раз сходить в БД и актуализировать кэш.

## Тестирование:
1. Зарегистрируйтесь через специальный роут
2. Залогинтесь через форму
3. Создайте товар, можете понаблюдать как меняется статус заказа каждую минуту благодаря работе ворекра. Узнать его текущий статус тоже можно через специальный ендпоинт
4. Попробуйте поменять статсус заказа самостоятельно

## Запуск
Входим в директорию проекта, выполняем: 
`docker compose up -d`

При этом развернется контейнер с `Redis`, контейнер в `PostgreSQL` ну и контейнер с `RabbitMQ`, если с ними все в порядке, развернется контейнер с приложением. Приложение после развертывания сконфигурирует `PostgreSQL`, запустит воркер и запустит `uvicorn`.

Переходим по адресу: 
`http://127.0.0.1:8000/docs#/`
